## CL-TO-PYTHON - common lisp библиотека для взаимодействия с Python

### Загрузка в лисп-систему:
#### Первый способ:
 - Установить quicklisp: `https://www.quicklisp.org/beta/`
 - `(load "<путь_к_cl-to-python>/load.lisp")`

#### Второй способ:
 - Установить quicklisp: `https://www.quicklisp.org/beta/`
 - Добавить путь к системе в ASDF: 
   - `(push #P"<<путь_к_cl-to-python>/" asdf:*central-registry*)`
 - Загрузить через Quicklisp: (ql:quickload :cl-to-python)

### Запуск тестов (после загрузки в лисп-систему)
 - `(asdf:test-system :cl-to-python)`

### Использование (после входа в пакет `cl-to-python` или после импорта этого пакета)
 - Сделать активным пакет `cl-to-python`: `(in-package #:cl-to-python)`
   (или импортировать `cl-to-python` в свой пакет, см. `defpackage`)
 - Запуск python-процесса: `(py-start)`
 - Остановка python-процесса: `(py-stop)`
 - Динамическая переменная `*python*` после `(py-start)` будет содержать экземпляр 
   структуры `PYTHON-CONN`, инкапсулирующую сущности необходимые для взаимодействия с python-процессом
   Eсли требуется запускать несколько python-процессов, эту переменную необходимо перекрыть, например 
   через форму let: `(let ((*python* nil)) (py-start) ...)`
 - 

### Требования
 - В данный момент протестировано в:
   - ОС: windows-10
   - Лисп: "SBCL 2.2.9" (на более ранней >= 2.0.0 - скорее всего, также будет работать)
    
### Итоговые требования
 - Планируется достичь работоспособности также в популярных linux-системах, например в Ubuntu 20.04/22.04
 - Также необходимо обеспечить работу в lispworks (для этого надо обеспечить поддержку в lispworks `uiop:launch-program`)

### Инструкции по работе с репозиторием
 - Перед коммитами, push-ами, крайне желательно проверять что сохранилась работоспособность системы,
   через запуск тестов `(asdf:test-system :cl-to-python)`

### Детали реализации, проблемы
 - Назначение файлов на данный момент:
   - parsers.lisp - здесь перевод результатов из строк в лисп-типы
   - cl-to-python.lisp - основная логика, в данный момент здесь
   - my2.py (будет переименован) - скрипт поддержки системы на стороне python-процесса
 - Принцип работы:
 - По какой-то причине, передать данные в канал и просто ожидать что python-процесс их прочтёт и будет
   продолжать обработку - не получается, так как python-процесс продолжает висеть в ожидании данных (тоже 
   самое наблюдалось и в обратном случае, в ожидании данных лисп-процессом). Это решается передачей 
   дополнительных данных. Этот момент требует исследования и как минимум выявления того,
   как именно и сколько надо передавать дополнительных данных.
 - Ф-ия `(py-stop)` приводит к завершению процесса консоли, запускающего python-процесс,
   таким образом, python остаётся висеть в памяти. Для того, чтобы он уничтожался после уничтожения родителя,
   в python-скрипте поддержки работы системы (сейчас my2.py, будет переименован) запускается поток проверяющий
   существование родителя - если родитель перестал существовать, он уничтожает python-процесс.
   Это нужно сделать как-то по-другому. Пока не понятно как. Может быть как-то передать в лисп-процесс, 
   PID python-процесса. Может быть, повесить в python-e обработчик сигнала, который должен передаваться,
   после завершения родителя

### Планы развития
 - Усовершенствовать систему логирования
 - В структуру `PYTHON-CONN` добавить все сущности связанные с взаимодействием с python-процессом
 - Рефакторинг (в частности, разбить функционал из cl-to-python.lisp на несколько файлов)
   + оптимизация
   + документирование
 - Сделать также реализацию на базе сокетов (tcp/udp)
 - Сохранить реализацию через каналы
   - добавить конфигурационный параметр, активирующий tcp/udp/default-pipes/custom-pipes, где:
     - default-pipes - это стандартные каналы ввода вывода
     - custom-pipes - это специально созданные каналы ввода-вывода
       (предполагается, что можно сделать свои каналы и обмениваться данными, чтобы небыло
       необходимости использовать и подменять стандартные каналы ввода вывода)
 - Исследовать механизм работы с каналами, избавиться от лишних пересылок данных
 - Сделать больше тестов, в частности стресс-тесты, чтобы понять пределы интенсивности обмена данными
 - Передавать бинарные данные, а не текстовые (по крайней мере от python-процесса к лисп-системе). 
   Но это потом, после качественной реализации всего остального.
 - Может быть, реализовать передачу результатов через общую память (но это тоже "сильно потом")
